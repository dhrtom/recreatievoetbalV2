@page "/"
@inject HttpClient Http
@using Blazor.Extensions
@inject INotificationService Notifications

<h1>Hello, world!</h1>

Welcome to your new app.
<div class="jumbotron">
    <p>Demo</p>
    Serviceworkers: @(_subscriptionResult?.serviceWorkerSupported)<br/>
    Push allowed: @(_subscriptionResult?.pushApiSupported)<br/>
    Blocked: @(_subscriptionResult?.notificationsBlocked)<br/>
    Subscribed: @(_subscriptionResult?.subscription != null ? "Ja" : "Nee")<br/>
    Endpoint: @(_subscriptionResult?.subscription?.Endpoint)<br/>
    serverSubscription: @(_subscriptionResult?.serverSubscription)<br/>
    Error: @(_subscriptionResult?.error)<br/>
    <a class="btn btn-primary btn-lg" onclick="@SubscribeOrUnsubscribee" role="button">@(_subscriptionResult?.subscription == null || _subscriptionResult?.serverSubscription != "True" ? "Ontvang notificaties" : "Afmelden voor notificaties")</a>

    <div id="subscriptionContext"> </div>
</div>

@functions{
    private GetSubscriptionResult _subscriptionResult = null;
    private string _applicationServerPublicKeyBase64 = null;

    private async Task<T> DoJsPromise<T>(string setFunction, string getFunction, params object[] parameters) where T : class
    {
        Console.WriteLine($"DoJsPromise {setFunction} - {getFunction}");
        var result = await JSRuntime.Current.InvokeAsync<T>(getFunction, parameters);
        if (result != null)
        {
            return result;
        }
        await JSRuntime.Current.InvokeAsync<bool>(setFunction, parameters);
        var tries = 0;
        // try 60 seconds
        while (result == null && tries < 600)
        {
            tries++;
            result = await JSRuntime.Current.InvokeAsync<T>(getFunction);
            if (result != null)
            {
                Console.WriteLine($"return {getFunction} = {result}");
                return result;
            }
            await Task.Delay(100);
        }
        return default(T);
    }
    private string _domain = "http://localhost:8001";
//    private string _domain = "https://api.konijn.it";

    protected override async Task OnInitAsync()
    {
        await DoJsPromise<object>("InitPushNotifications", "GetPushServiceWorkerRegistrationResult");
        _subscriptionResult = await DoJsPromise<GetSubscriptionResult>("SetSubscription", "GetSubscriptionResult");
        if (_subscriptionResult?.subscription?.Endpoint != null)
        {
            _subscriptionResult.serverSubscription = await Http.GetStringAsync($"{_domain}/push-notifications-api/subscriptions?endpoint=" + _subscriptionResult.subscription.Endpoint);
        }
    }

    async Task SubscribeOrUnsubscribee()
    {
        if (_subscriptionResult?.subscription == null || _subscriptionResult?.serverSubscription != "True")
        {
            // Subscribe
            if (_subscriptionResult?.subscription == null)
            {
                if (_applicationServerPublicKeyBase64 == null)
                {
                    _applicationServerPublicKeyBase64 = await Http.GetStringAsync($"{_domain}/push-notifications-api/public-key");
                }
                _subscriptionResult = await DoJsPromise<GetSubscriptionResult>("SubscribeForPushNotifications", "GetSubscriptionResult", _applicationServerPublicKeyBase64);
            }
            if (_subscriptionResult?.subscription != null)
            {
                await Http.PostJsonAsync($"{_domain}/push-notifications-api/subscriptions", _subscriptionResult.subscription);
                _subscriptionResult.serverSubscription = "True";
            }
        }
        else
        {
            await DoJsPromise<GetSubscriptionResult>("UnsubscribeForPushNotifications", "GetSubscriptionResult");
            await Http.DeleteAsync($"{_domain}/push-notifications-api/subscriptions/?endpoint=" + _subscriptionResult.subscription.Endpoint);
            _subscriptionResult.subscription = null;            
            _subscriptionResult.serverSubscription = null;            
        }
    }

    class PushSubscription
    {
        /// <summary>Gets or sets the subscription endpoint.</summary>
        public string Endpoint { get; set; }

        /// <summary>
    /// Gets or sets client keys shared as part of subscription.
    /// </summary>
        public IDictionary<string, string> Keys { get; set; }

        /// <summary>
    /// Gets specific client key shared as part of subscription.
    /// </summary>
    /// <param name="keyName">The key name.</param>
    /// <returns>The key.</returns>
        public string GetKey(PushEncryptionKeyName keyName)
        {
            string str = (string) null;
            if (this.Keys != null)
            {
                string key = this.StringifyKeyName(keyName);
                if (this.Keys.ContainsKey(key))
                    str = this.Keys[key];
            }
            return str;
        }

        /// <summary>
    /// Sets specific client key shared as part of subscription.
    /// </summary>
    /// <param name="keyName">The key name.</param>
    /// <param name="key">The key.</param>
        public void SetKey(PushEncryptionKeyName keyName, string key)
        {
            if (this.Keys == null)
                this.Keys = (IDictionary<string, string>) new Dictionary<string, string>();
            this.Keys[this.StringifyKeyName(keyName)] = key;
        }

        private string StringifyKeyName(PushEncryptionKeyName keyName)
        {
            return keyName.ToString().ToLowerInvariant();
        }
    }
    
    public enum PushEncryptionKeyName
    {
        /// <summary>The client P-256 public key for use in ECDH.</summary>
        P256DH,
        /// <summary>The client authentication secret.</summary>
        Auth,
    }
    
    class GetSubscriptionResult
    {
        public bool notificationsBlocked { get; set; }
        public PushSubscription subscription { get; set; }
        public string serverSubscription { get; set; }
        public bool serviceWorkerSupported { get; set; }
        public bool pushApiSupported { get; set; }
        public string error { get; set; }
    }
}
